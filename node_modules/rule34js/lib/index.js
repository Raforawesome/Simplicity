"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.posts = void 0;
const fast_xml_parser_1 = require("fast-xml-parser");
const bent = require("bent");
const parseroptions = {
    attributeNamePrefix: "",
    //attrNodeName: false, //default is 'false'
    textNodeName: "#text",
    ignoreAttributes: false,
    ignoreNameSpace: false,
    allowBooleanAttributes: false,
    parseNodeValue: true,
    parseAttributeValue: true,
    trimValues: false,
    cdataTagName: "__cdata",
    cdataPositionChar: "\\c",
    parseTrueNumberOnly: false,
    arrayMode: false,
    stopNodes: ["parse-me-as-string"]
};
const fetchString = bent('string');
/**
 * Returns massive of posts
 * @param {Rule34OptionsOptional} options
 * @returns {Post[]}
 */
async function posts(options) {
    if (options == {} || options == null) {
        throw "nope";
    }
    options.tags = options.tags || ["all"];
    options.parse_tags = options.parse_tags || true;
    options.remove_empty = options.remove_empty || true;
    options.pid = options.pid || 0;
    options.limit = options.limit || 100;
    if (options.limit > 100)
        console.warn("rule34js: 100 is limit, using everything larger makes no sense");
    const url = `https://rule34.xxx/index.php?page=dapi&s=post&q=index&tags=${options.tags.join("+")}&pid=${options.pid}&limit=${options.limit}`;
    const obj = await fetchString(url);
    const json = fast_xml_parser_1.parse(obj, parseroptions, true);
    if (json.posts && json.posts.post && options.parse_tags) {
        if (options.remove_empty) {
            for (let postI = 0; postI < json.posts.post.length; postI++) {
                let cpost = json.posts.post[postI];
                cpost.tags_parsed = cpost.tags.split(" ").filter((val) => { return val != ""; });
            }
        }
        else {
            for (let postI = 0; postI < json.posts.post.length; postI++) {
                let cpost = json.posts.post[postI];
                cpost.tags_parsed = cpost.tags.split(" ");
            }
        }
    }
    return { count: (json.posts ? json.posts.count : 0), offset: (json.posts ? json.posts.offset : 0), posts: (json.posts ? json.posts.post : []) };
}
exports.posts = posts;
